# 서로소 집합

- 서로소 집합(Disjoint Sets)란 <u>공통 원소가 없는 두 집합</u>을 의미합니다.

      {1, 2} 와 {3, 4}는 서로소 관계이다
      {1, 2} 와 {2, 3}은 서로소 관계가 아니다.

### 서로소 집합 자료구조

- <u>서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조</u>입니다.
- 서로소 집합 자료구조는 두 종류의 연산을 지원합니다.
    - **합집합(Union):** 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산입니다.
    - **찾기(Find):** 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 원소입니다.

- 서로소 집합 자료구조는 **합치기 찾기(Union Find) 자료구조** 라고 불리기도 합니다.

### 서로소 집합 자료구조: 동작 과정 살펴보기

- 여러 개의 합치기 연산이 주어졌을 때 서로소 집합 자료구조의 동작 과정은 다음과 같습니다.,
    1. 합집합(Union) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인합니다.
        1) A와 B의 루트 노드 A', B'를 각각 찾습니다.
        2) A'를 B'의 부모 노드로 설정합니다.
    2. 모든 합집합(Union) 연산을 처리할 때까지 1번의 과정을 반복합니다.

####

    처리할 연산들: Union(1,4), Union(2,3), Union(2,4), Union(5,6)

- [초기 단계] 노드의 개수 크기의 부모 테이블을 초기화 합니다.
  <img src="https://user-images.githubusercontent.com/2025813/105996380-964bd580-60ed-11eb-9f91-e7cc527da337.jpg" width="60%" height="60%">

- [Step 1] 노드 1과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 1과 4이므로 더 큰 번호에 해당하는 루트 노드 4의 부모를 1로 설정합니다.

  <img src="https://user-images.githubusercontent.com/2025813/105996388-977d0280-60ed-11eb-8fc7-6af1642e482e.jpg" width="60%" height="60%">

- [Step 2] 노드 2과 노드 3의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 3이므로 더 큰 번호에 해당하는 루트 노드 3의 부로를 2로 설정합니다.

  <img src="https://user-images.githubusercontent.com/2025813/105996671-035f6b00-60ee-11eb-8795-7acf240096f4.jpg" width="60%" height="60%">

- [Step 3] 노드 2과 노드 4의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 2와 1이므로 더 큰 번호에 해당하는 루트 노드 2의 부모를 1로 설정합니다.

  <img src="https://user-images.githubusercontent.com/2025813/105997002-6cdf7980-60ee-11eb-9990-d2bb691370a3.jpg" width="60%" height="60%">

- [Step 4] 노드 5과 노드 6의 루트 노드를 각각 찾습니다. 현재 루트 노드는 각각 5와 6이므로 더 큰 번호에 해당하는 루트 노드 6의 부모를 5로 설정합니다.

  <img src="https://user-images.githubusercontent.com/2025813/105997319-d2cc0100-60ee-11eb-9071-6976cbc770c7.jpg" width="60%" height="60%">

### 서로소 자료구조: 연결성

- 서로소 집합 자료구조에서는 **연결성**을 통해 손쉽게 집합의 형태를 확인할 수 있습니다.

  <img src="https://user-images.githubusercontent.com/2025813/105997509-09a21700-60ef-11eb-920d-a228c9725f7e.jpg" width="60%" height="60%">


- 기본적인 형태의 서로소 집합 자료구조에서는 루트 노드에 즉시 접근할 수 없습니다.
    - 루트 노드를 찾기 위해 <u>부모 테이블을 계속해서 확인</u>하며 거슬러 올라가야 합니다.

- 위 예시에서 노드 3의 루트를 찾기 위해서는 노드 2를 거쳐 노드 1에 접근해야합니다.

### 서로소 자료구조: 기본적인 구현 방법의 문제점

- 합집합(Union) 연산이 편향되게 이루어지는 경우 찾기(Find) 함수가 비효율적으로 동작합니다.
- 최악의 경우에는 찾기(Find) 함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 O(V)입니다.
    - 다음과 같이 {1, 2, 3, 4, 5}의 총 5개의 원소가 존재하는 상황을 확인해 봅시다.
    - **수행된 연산들:** Union(4,5), Union(3,4), Union(2,3), Union(1,2)

### 서로소 자료구조: 경로 압축

- 찾기(Find) 함수를 최적화하기 위한 방법으로 경로 압축(Path Compression)을 이용할 수 있습니다.
    - 찾기(Find) 함수를 재귀적으로 호출한 뒤에 <u>부모 테이블 값을 바로 갱신</u>합니다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]
```

- 경로 압축 기법을 적용하면 각 노드에 대하여 <u>찾기(Find) 함수를 호출한 이후에</u> 해당 노드의 루트 노드가 바로 부모 노드가 됩니다.
- 동일한 예시에 대해서 **모든 합집합(Union) 함수를 처리한 후 각 원소에 대하여 찾기(Find) 함수를 수행하면 다음과 같이 부모 테이블이 갱신**됩니다.
- 기본적인 방법에 비하여 시간복잡도가 개선됩니다.
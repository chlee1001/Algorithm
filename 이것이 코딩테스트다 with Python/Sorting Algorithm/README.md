# 정렬(Sorting) 알고리즘

- **정렬**이란 <u>데이터를 특정한 기준에 따라 순서대로 나열</u>하는 것을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.

### 선택정렬

- 처리되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복**합니다.

#### 선택정렬의 시간복잡도

- 선택 정렬은 N번만큼 가장 작은 수를 찾아서 맨 앞으로 보내야합니다.
- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다.

        N + (N - 1) + (N - 2) + ... + 2
- 이는 (N^2 + N -2) / 2로 표현할 수 있는데, 빅오 표기법에 따라서 O(N^2)이라고 작성합니다.

###

### 삽입정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에** 삽입합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.

#### 삽입정렬의 시간복잡도

- 삽입정렬은 시간복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.
- 삽입정렬은 <u>현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작</u>합니다.
    - 최선의 경우 O(N)의 시간 복잡도를 가집니다.
        - **거의 정렬되어 있는 상태라면 퀵정렬등의 알고리즘보다 삽입정렬이 더 좋다**
    - 이미 정렬되어 있는 상태에서 다시 삽입정렬을 수행하면 어떻게 될까요?

###

### 퀵정렬

- <u>기준 데이터를 설정</u>하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**입니다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.
- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정합니다.

#### 퀵정렬의 시간복잡도

- 퀵 정렬은 평균의 경우 O(NlogN)의 시간복도를 가집니다.
- 하지만 최악의 경우 O(N^2)의 시간복잡도를 가집니다.
    - 피벗의 위치에 따라 한쪽으로 편향되어 정렬될 수 있다.
    - 첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서...

###

### 계수정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는** 정렬알고리즘입니다.
    - 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용가능합니다.

- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일때 최악의 경우에도 수행 시간 O(N + K)를 보장합니다.

#### 계수정렬의 복잡도

- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N + K)입니다.
- 계수 정렬은 떄에 따라서 심각한 비효율성을 초래할 수 있습니다.
    - 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해 봅시다.

- 계수 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다.
    - 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다.

## 정렬 알고리즘 비교하기

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| :-----------: | :--------------: | :---------: | :----------------------------------------------------------- |
|   선택 정렬   |      O(N^2)      |    O(N)     | 아이디어가 매우 간단합니다.                                  |
|   삽입 정렬   |      O(N^2)      |    O(N)     | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.              |
|    퀵 정렬    |     O(NlogN)     |    O(N)     | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.              |
|   계수 정렬   |     O(N + K)     |  O(N + K)   | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다. |

<u>표준 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장</u>